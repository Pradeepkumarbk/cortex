// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: alertcortex.proto

/*
	Package client is a generated protocol buffer package.

	It is generated from these files:
		alertcortex.proto

	It has these top-level messages:
		WriteRequest
		WriteResponse
		ReadRequest
		ReadResponse
		QueryRequest
		QueryResponse
		LabelValuesRequest
		LabelValuesResponse
		UserStatsRequest
		UserStatsResponse
		MetricsForLabelMatchersRequest
		MetricsForLabelMatchersResponse
		TimeSeriesChunk
		Chunk
		TransferChunksResponse
		MessageTracker
		LabelPair
		Sample
		LabelMatchers
		Metric
		LabelMatcher
*/
package client

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import github_com_weaveworks_cortex_pkg_util_wire "github.com/weaveworks/cortex/pkg/util/wire"

import strconv "strconv"

import bytes "bytes"

import strings "strings"
import reflect "reflect"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type MatchType int32

const (
	EQUAL          MatchType = 0
	NOT_EQUAL      MatchType = 1
	REGEX_MATCH    MatchType = 2
	REGEX_NO_MATCH MatchType = 3
)

var MatchType_name = map[int32]string{
	0: "EQUAL",
	1: "NOT_EQUAL",
	2: "REGEX_MATCH",
	3: "REGEX_NO_MATCH",
}
var MatchType_value = map[string]int32{
	"EQUAL":          0,
	"NOT_EQUAL":      1,
	"REGEX_MATCH":    2,
	"REGEX_NO_MATCH": 3,
}

func (MatchType) EnumDescriptor() ([]byte, []int) { return fileDescriptorAlertcortex, []int{0} }

type WriteRequest struct {
	Messages []MessageTracker `protobuf:"bytes,1,rep,name=messages" json:"messages"`
}

func (m *WriteRequest) Reset()                    { *m = WriteRequest{} }
func (*WriteRequest) ProtoMessage()               {}
func (*WriteRequest) Descriptor() ([]byte, []int) { return fileDescriptorAlertcortex, []int{0} }

func (m *WriteRequest) GetMessages() []MessageTracker {
	if m != nil {
		return m.Messages
	}
	return nil
}

type WriteResponse struct {
}

func (m *WriteResponse) Reset()                    { *m = WriteResponse{} }
func (*WriteResponse) ProtoMessage()               {}
func (*WriteResponse) Descriptor() ([]byte, []int) { return fileDescriptorAlertcortex, []int{1} }

type ReadRequest struct {
	Queries []*QueryRequest `protobuf:"bytes,1,rep,name=queries" json:"queries,omitempty"`
}

func (m *ReadRequest) Reset()                    { *m = ReadRequest{} }
func (*ReadRequest) ProtoMessage()               {}
func (*ReadRequest) Descriptor() ([]byte, []int) { return fileDescriptorAlertcortex, []int{2} }

func (m *ReadRequest) GetQueries() []*QueryRequest {
	if m != nil {
		return m.Queries
	}
	return nil
}

type ReadResponse struct {
	Results []*QueryResponse `protobuf:"bytes,1,rep,name=results" json:"results,omitempty"`
}

func (m *ReadResponse) Reset()                    { *m = ReadResponse{} }
func (*ReadResponse) ProtoMessage()               {}
func (*ReadResponse) Descriptor() ([]byte, []int) { return fileDescriptorAlertcortex, []int{3} }

func (m *ReadResponse) GetResults() []*QueryResponse {
	if m != nil {
		return m.Results
	}
	return nil
}

type QueryRequest struct {
	StartTimestampMs int64           `protobuf:"varint,1,opt,name=start_timestamp_ms,json=startTimestampMs,proto3" json:"start_timestamp_ms,omitempty"`
	EndTimestampMs   int64           `protobuf:"varint,2,opt,name=end_timestamp_ms,json=endTimestampMs,proto3" json:"end_timestamp_ms,omitempty"`
	Matchers         []*LabelMatcher `protobuf:"bytes,3,rep,name=matchers" json:"matchers,omitempty"`
}

func (m *QueryRequest) Reset()                    { *m = QueryRequest{} }
func (*QueryRequest) ProtoMessage()               {}
func (*QueryRequest) Descriptor() ([]byte, []int) { return fileDescriptorAlertcortex, []int{4} }

func (m *QueryRequest) GetStartTimestampMs() int64 {
	if m != nil {
		return m.StartTimestampMs
	}
	return 0
}

func (m *QueryRequest) GetEndTimestampMs() int64 {
	if m != nil {
		return m.EndTimestampMs
	}
	return 0
}

func (m *QueryRequest) GetMatchers() []*LabelMatcher {
	if m != nil {
		return m.Matchers
	}
	return nil
}

type QueryResponse struct {
	Messages []MessageTracker `protobuf:"bytes,1,rep,name=messages" json:"messages"`
}

func (m *QueryResponse) Reset()                    { *m = QueryResponse{} }
func (*QueryResponse) ProtoMessage()               {}
func (*QueryResponse) Descriptor() ([]byte, []int) { return fileDescriptorAlertcortex, []int{5} }

func (m *QueryResponse) GetMessages() []MessageTracker {
	if m != nil {
		return m.Messages
	}
	return nil
}

type LabelValuesRequest struct {
	LabelName string `protobuf:"bytes,1,opt,name=label_name,json=labelName,proto3" json:"label_name,omitempty"`
}

func (m *LabelValuesRequest) Reset()                    { *m = LabelValuesRequest{} }
func (*LabelValuesRequest) ProtoMessage()               {}
func (*LabelValuesRequest) Descriptor() ([]byte, []int) { return fileDescriptorAlertcortex, []int{6} }

func (m *LabelValuesRequest) GetLabelName() string {
	if m != nil {
		return m.LabelName
	}
	return ""
}

type LabelValuesResponse struct {
	LabelValues []string `protobuf:"bytes,1,rep,name=label_values,json=labelValues" json:"label_values,omitempty"`
}

func (m *LabelValuesResponse) Reset()                    { *m = LabelValuesResponse{} }
func (*LabelValuesResponse) ProtoMessage()               {}
func (*LabelValuesResponse) Descriptor() ([]byte, []int) { return fileDescriptorAlertcortex, []int{7} }

func (m *LabelValuesResponse) GetLabelValues() []string {
	if m != nil {
		return m.LabelValues
	}
	return nil
}

type UserStatsRequest struct {
}

func (m *UserStatsRequest) Reset()                    { *m = UserStatsRequest{} }
func (*UserStatsRequest) ProtoMessage()               {}
func (*UserStatsRequest) Descriptor() ([]byte, []int) { return fileDescriptorAlertcortex, []int{8} }

type UserStatsResponse struct {
	IngestionRate float64 `protobuf:"fixed64,1,opt,name=ingestion_rate,json=ingestionRate,proto3" json:"ingestion_rate,omitempty"`
	NumSeries     uint64  `protobuf:"varint,2,opt,name=num_series,json=numSeries,proto3" json:"num_series,omitempty"`
}

func (m *UserStatsResponse) Reset()                    { *m = UserStatsResponse{} }
func (*UserStatsResponse) ProtoMessage()               {}
func (*UserStatsResponse) Descriptor() ([]byte, []int) { return fileDescriptorAlertcortex, []int{9} }

func (m *UserStatsResponse) GetIngestionRate() float64 {
	if m != nil {
		return m.IngestionRate
	}
	return 0
}

func (m *UserStatsResponse) GetNumSeries() uint64 {
	if m != nil {
		return m.NumSeries
	}
	return 0
}

type MetricsForLabelMatchersRequest struct {
	StartTimestampMs int64            `protobuf:"varint,1,opt,name=start_timestamp_ms,json=startTimestampMs,proto3" json:"start_timestamp_ms,omitempty"`
	EndTimestampMs   int64            `protobuf:"varint,2,opt,name=end_timestamp_ms,json=endTimestampMs,proto3" json:"end_timestamp_ms,omitempty"`
	MatchersSet      []*LabelMatchers `protobuf:"bytes,3,rep,name=matchers_set,json=matchersSet" json:"matchers_set,omitempty"`
}

func (m *MetricsForLabelMatchersRequest) Reset()      { *m = MetricsForLabelMatchersRequest{} }
func (*MetricsForLabelMatchersRequest) ProtoMessage() {}
func (*MetricsForLabelMatchersRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorAlertcortex, []int{10}
}

func (m *MetricsForLabelMatchersRequest) GetStartTimestampMs() int64 {
	if m != nil {
		return m.StartTimestampMs
	}
	return 0
}

func (m *MetricsForLabelMatchersRequest) GetEndTimestampMs() int64 {
	if m != nil {
		return m.EndTimestampMs
	}
	return 0
}

func (m *MetricsForLabelMatchersRequest) GetMatchersSet() []*LabelMatchers {
	if m != nil {
		return m.MatchersSet
	}
	return nil
}

type MetricsForLabelMatchersResponse struct {
	Metric []*Metric `protobuf:"bytes,1,rep,name=metric" json:"metric,omitempty"`
}

func (m *MetricsForLabelMatchersResponse) Reset()      { *m = MetricsForLabelMatchersResponse{} }
func (*MetricsForLabelMatchersResponse) ProtoMessage() {}
func (*MetricsForLabelMatchersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorAlertcortex, []int{11}
}

func (m *MetricsForLabelMatchersResponse) GetMetric() []*Metric {
	if m != nil {
		return m.Metric
	}
	return nil
}

type TimeSeriesChunk struct {
	FromIngesterId string      `protobuf:"bytes,1,opt,name=from_ingester_id,json=fromIngesterId,proto3" json:"from_ingester_id,omitempty"`
	UserId         string      `protobuf:"bytes,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Labels         []LabelPair `protobuf:"bytes,3,rep,name=labels" json:"labels"`
	Chunks         []Chunk     `protobuf:"bytes,4,rep,name=chunks" json:"chunks"`
}

func (m *TimeSeriesChunk) Reset()                    { *m = TimeSeriesChunk{} }
func (*TimeSeriesChunk) ProtoMessage()               {}
func (*TimeSeriesChunk) Descriptor() ([]byte, []int) { return fileDescriptorAlertcortex, []int{12} }

func (m *TimeSeriesChunk) GetFromIngesterId() string {
	if m != nil {
		return m.FromIngesterId
	}
	return ""
}

func (m *TimeSeriesChunk) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *TimeSeriesChunk) GetLabels() []LabelPair {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *TimeSeriesChunk) GetChunks() []Chunk {
	if m != nil {
		return m.Chunks
	}
	return nil
}

type Chunk struct {
	StartTimestampMs int64  `protobuf:"varint,1,opt,name=start_timestamp_ms,json=startTimestampMs,proto3" json:"start_timestamp_ms,omitempty"`
	EndTimestampMs   int64  `protobuf:"varint,2,opt,name=end_timestamp_ms,json=endTimestampMs,proto3" json:"end_timestamp_ms,omitempty"`
	Encoding         int32  `protobuf:"varint,3,opt,name=encoding,proto3" json:"encoding,omitempty"`
	Data             []byte `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *Chunk) Reset()                    { *m = Chunk{} }
func (*Chunk) ProtoMessage()               {}
func (*Chunk) Descriptor() ([]byte, []int) { return fileDescriptorAlertcortex, []int{13} }

func (m *Chunk) GetStartTimestampMs() int64 {
	if m != nil {
		return m.StartTimestampMs
	}
	return 0
}

func (m *Chunk) GetEndTimestampMs() int64 {
	if m != nil {
		return m.EndTimestampMs
	}
	return 0
}

func (m *Chunk) GetEncoding() int32 {
	if m != nil {
		return m.Encoding
	}
	return 0
}

func (m *Chunk) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type TransferChunksResponse struct {
}

func (m *TransferChunksResponse) Reset()      { *m = TransferChunksResponse{} }
func (*TransferChunksResponse) ProtoMessage() {}
func (*TransferChunksResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorAlertcortex, []int{14}
}

type MessageTracker struct {
	Labels    string `protobuf:"bytes,1,opt,name=labels,proto3" json:"labels,omitempty"`
	Timestamp int64  `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Value     string `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *MessageTracker) Reset()                    { *m = MessageTracker{} }
func (*MessageTracker) ProtoMessage()               {}
func (*MessageTracker) Descriptor() ([]byte, []int) { return fileDescriptorAlertcortex, []int{15} }

func (m *MessageTracker) GetLabels() string {
	if m != nil {
		return m.Labels
	}
	return ""
}

func (m *MessageTracker) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *MessageTracker) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type LabelPair struct {
	Name  github_com_weaveworks_cortex_pkg_util_wire.Bytes `protobuf:"bytes,1,opt,name=name,proto3,customtype=github.com/weaveworks/cortex/pkg/util/wire.Bytes" json:"name"`
	Value github_com_weaveworks_cortex_pkg_util_wire.Bytes `protobuf:"bytes,2,opt,name=value,proto3,customtype=github.com/weaveworks/cortex/pkg/util/wire.Bytes" json:"value"`
}

func (m *LabelPair) Reset()                    { *m = LabelPair{} }
func (*LabelPair) ProtoMessage()               {}
func (*LabelPair) Descriptor() ([]byte, []int) { return fileDescriptorAlertcortex, []int{16} }

type Sample struct {
	Value       float64 `protobuf:"fixed64,1,opt,name=value,proto3" json:"value,omitempty"`
	TimestampMs int64   `protobuf:"varint,2,opt,name=timestamp_ms,json=timestampMs,proto3" json:"timestamp_ms,omitempty"`
}

func (m *Sample) Reset()                    { *m = Sample{} }
func (*Sample) ProtoMessage()               {}
func (*Sample) Descriptor() ([]byte, []int) { return fileDescriptorAlertcortex, []int{17} }

func (m *Sample) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *Sample) GetTimestampMs() int64 {
	if m != nil {
		return m.TimestampMs
	}
	return 0
}

type LabelMatchers struct {
	Matchers []*LabelMatcher `protobuf:"bytes,1,rep,name=matchers" json:"matchers,omitempty"`
}

func (m *LabelMatchers) Reset()                    { *m = LabelMatchers{} }
func (*LabelMatchers) ProtoMessage()               {}
func (*LabelMatchers) Descriptor() ([]byte, []int) { return fileDescriptorAlertcortex, []int{18} }

func (m *LabelMatchers) GetMatchers() []*LabelMatcher {
	if m != nil {
		return m.Matchers
	}
	return nil
}

type Metric struct {
	Labels []LabelPair `protobuf:"bytes,1,rep,name=labels" json:"labels"`
}

func (m *Metric) Reset()                    { *m = Metric{} }
func (*Metric) ProtoMessage()               {}
func (*Metric) Descriptor() ([]byte, []int) { return fileDescriptorAlertcortex, []int{19} }

func (m *Metric) GetLabels() []LabelPair {
	if m != nil {
		return m.Labels
	}
	return nil
}

type LabelMatcher struct {
	Type  MatchType `protobuf:"varint,1,opt,name=type,proto3,enum=alertcortex.MatchType" json:"type,omitempty"`
	Name  string    `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Value string    `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *LabelMatcher) Reset()                    { *m = LabelMatcher{} }
func (*LabelMatcher) ProtoMessage()               {}
func (*LabelMatcher) Descriptor() ([]byte, []int) { return fileDescriptorAlertcortex, []int{20} }

func (m *LabelMatcher) GetType() MatchType {
	if m != nil {
		return m.Type
	}
	return EQUAL
}

func (m *LabelMatcher) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LabelMatcher) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func init() {
	proto.RegisterType((*WriteRequest)(nil), "alertcortex.WriteRequest")
	proto.RegisterType((*WriteResponse)(nil), "alertcortex.WriteResponse")
	proto.RegisterType((*ReadRequest)(nil), "alertcortex.ReadRequest")
	proto.RegisterType((*ReadResponse)(nil), "alertcortex.ReadResponse")
	proto.RegisterType((*QueryRequest)(nil), "alertcortex.QueryRequest")
	proto.RegisterType((*QueryResponse)(nil), "alertcortex.QueryResponse")
	proto.RegisterType((*LabelValuesRequest)(nil), "alertcortex.LabelValuesRequest")
	proto.RegisterType((*LabelValuesResponse)(nil), "alertcortex.LabelValuesResponse")
	proto.RegisterType((*UserStatsRequest)(nil), "alertcortex.UserStatsRequest")
	proto.RegisterType((*UserStatsResponse)(nil), "alertcortex.UserStatsResponse")
	proto.RegisterType((*MetricsForLabelMatchersRequest)(nil), "alertcortex.MetricsForLabelMatchersRequest")
	proto.RegisterType((*MetricsForLabelMatchersResponse)(nil), "alertcortex.MetricsForLabelMatchersResponse")
	proto.RegisterType((*TimeSeriesChunk)(nil), "alertcortex.TimeSeriesChunk")
	proto.RegisterType((*Chunk)(nil), "alertcortex.Chunk")
	proto.RegisterType((*TransferChunksResponse)(nil), "alertcortex.TransferChunksResponse")
	proto.RegisterType((*MessageTracker)(nil), "alertcortex.messageTracker")
	proto.RegisterType((*LabelPair)(nil), "alertcortex.LabelPair")
	proto.RegisterType((*Sample)(nil), "alertcortex.Sample")
	proto.RegisterType((*LabelMatchers)(nil), "alertcortex.LabelMatchers")
	proto.RegisterType((*Metric)(nil), "alertcortex.Metric")
	proto.RegisterType((*LabelMatcher)(nil), "alertcortex.LabelMatcher")
	proto.RegisterEnum("alertcortex.MatchType", MatchType_name, MatchType_value)
}
func (x MatchType) String() string {
	s, ok := MatchType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *WriteRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WriteRequest)
	if !ok {
		that2, ok := that.(WriteRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Messages) != len(that1.Messages) {
		return false
	}
	for i := range this.Messages {
		if !this.Messages[i].Equal(&that1.Messages[i]) {
			return false
		}
	}
	return true
}
func (this *WriteResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WriteResponse)
	if !ok {
		that2, ok := that.(WriteResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *ReadRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReadRequest)
	if !ok {
		that2, ok := that.(ReadRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Queries) != len(that1.Queries) {
		return false
	}
	for i := range this.Queries {
		if !this.Queries[i].Equal(that1.Queries[i]) {
			return false
		}
	}
	return true
}
func (this *ReadResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReadResponse)
	if !ok {
		that2, ok := that.(ReadResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Results) != len(that1.Results) {
		return false
	}
	for i := range this.Results {
		if !this.Results[i].Equal(that1.Results[i]) {
			return false
		}
	}
	return true
}
func (this *QueryRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueryRequest)
	if !ok {
		that2, ok := that.(QueryRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StartTimestampMs != that1.StartTimestampMs {
		return false
	}
	if this.EndTimestampMs != that1.EndTimestampMs {
		return false
	}
	if len(this.Matchers) != len(that1.Matchers) {
		return false
	}
	for i := range this.Matchers {
		if !this.Matchers[i].Equal(that1.Matchers[i]) {
			return false
		}
	}
	return true
}
func (this *QueryResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueryResponse)
	if !ok {
		that2, ok := that.(QueryResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Messages) != len(that1.Messages) {
		return false
	}
	for i := range this.Messages {
		if !this.Messages[i].Equal(&that1.Messages[i]) {
			return false
		}
	}
	return true
}
func (this *LabelValuesRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LabelValuesRequest)
	if !ok {
		that2, ok := that.(LabelValuesRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.LabelName != that1.LabelName {
		return false
	}
	return true
}
func (this *LabelValuesResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LabelValuesResponse)
	if !ok {
		that2, ok := that.(LabelValuesResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.LabelValues) != len(that1.LabelValues) {
		return false
	}
	for i := range this.LabelValues {
		if this.LabelValues[i] != that1.LabelValues[i] {
			return false
		}
	}
	return true
}
func (this *UserStatsRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UserStatsRequest)
	if !ok {
		that2, ok := that.(UserStatsRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *UserStatsResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UserStatsResponse)
	if !ok {
		that2, ok := that.(UserStatsResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.IngestionRate != that1.IngestionRate {
		return false
	}
	if this.NumSeries != that1.NumSeries {
		return false
	}
	return true
}
func (this *MetricsForLabelMatchersRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MetricsForLabelMatchersRequest)
	if !ok {
		that2, ok := that.(MetricsForLabelMatchersRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StartTimestampMs != that1.StartTimestampMs {
		return false
	}
	if this.EndTimestampMs != that1.EndTimestampMs {
		return false
	}
	if len(this.MatchersSet) != len(that1.MatchersSet) {
		return false
	}
	for i := range this.MatchersSet {
		if !this.MatchersSet[i].Equal(that1.MatchersSet[i]) {
			return false
		}
	}
	return true
}
func (this *MetricsForLabelMatchersResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MetricsForLabelMatchersResponse)
	if !ok {
		that2, ok := that.(MetricsForLabelMatchersResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Metric) != len(that1.Metric) {
		return false
	}
	for i := range this.Metric {
		if !this.Metric[i].Equal(that1.Metric[i]) {
			return false
		}
	}
	return true
}
func (this *TimeSeriesChunk) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TimeSeriesChunk)
	if !ok {
		that2, ok := that.(TimeSeriesChunk)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FromIngesterId != that1.FromIngesterId {
		return false
	}
	if this.UserId != that1.UserId {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if !this.Labels[i].Equal(&that1.Labels[i]) {
			return false
		}
	}
	if len(this.Chunks) != len(that1.Chunks) {
		return false
	}
	for i := range this.Chunks {
		if !this.Chunks[i].Equal(&that1.Chunks[i]) {
			return false
		}
	}
	return true
}
func (this *Chunk) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Chunk)
	if !ok {
		that2, ok := that.(Chunk)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StartTimestampMs != that1.StartTimestampMs {
		return false
	}
	if this.EndTimestampMs != that1.EndTimestampMs {
		return false
	}
	if this.Encoding != that1.Encoding {
		return false
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return false
	}
	return true
}
func (this *TransferChunksResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TransferChunksResponse)
	if !ok {
		that2, ok := that.(TransferChunksResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *MessageTracker) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MessageTracker)
	if !ok {
		that2, ok := that.(MessageTracker)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Labels != that1.Labels {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *LabelPair) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LabelPair)
	if !ok {
		that2, ok := that.(LabelPair)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Name.Equal(that1.Name) {
		return false
	}
	if !this.Value.Equal(that1.Value) {
		return false
	}
	return true
}
func (this *Sample) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Sample)
	if !ok {
		that2, ok := that.(Sample)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if this.TimestampMs != that1.TimestampMs {
		return false
	}
	return true
}
func (this *LabelMatchers) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LabelMatchers)
	if !ok {
		that2, ok := that.(LabelMatchers)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Matchers) != len(that1.Matchers) {
		return false
	}
	for i := range this.Matchers {
		if !this.Matchers[i].Equal(that1.Matchers[i]) {
			return false
		}
	}
	return true
}
func (this *Metric) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Metric)
	if !ok {
		that2, ok := that.(Metric)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if !this.Labels[i].Equal(&that1.Labels[i]) {
			return false
		}
	}
	return true
}
func (this *LabelMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LabelMatcher)
	if !ok {
		that2, ok := that.(LabelMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *WriteRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&client.WriteRequest{")
	if this.Messages != nil {
		vs := make([]*MessageTracker, len(this.Messages))
		for i := range vs {
			vs[i] = &this.Messages[i]
		}
		s = append(s, "Messages: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WriteResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&client.WriteResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReadRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&client.ReadRequest{")
	if this.Queries != nil {
		s = append(s, "Queries: "+fmt.Sprintf("%#v", this.Queries)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReadResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&client.ReadResponse{")
	if this.Results != nil {
		s = append(s, "Results: "+fmt.Sprintf("%#v", this.Results)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueryRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&client.QueryRequest{")
	s = append(s, "StartTimestampMs: "+fmt.Sprintf("%#v", this.StartTimestampMs)+",\n")
	s = append(s, "EndTimestampMs: "+fmt.Sprintf("%#v", this.EndTimestampMs)+",\n")
	if this.Matchers != nil {
		s = append(s, "Matchers: "+fmt.Sprintf("%#v", this.Matchers)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueryResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&client.QueryResponse{")
	if this.Messages != nil {
		vs := make([]*MessageTracker, len(this.Messages))
		for i := range vs {
			vs[i] = &this.Messages[i]
		}
		s = append(s, "Messages: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LabelValuesRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&client.LabelValuesRequest{")
	s = append(s, "LabelName: "+fmt.Sprintf("%#v", this.LabelName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LabelValuesResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&client.LabelValuesResponse{")
	s = append(s, "LabelValues: "+fmt.Sprintf("%#v", this.LabelValues)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UserStatsRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&client.UserStatsRequest{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UserStatsResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&client.UserStatsResponse{")
	s = append(s, "IngestionRate: "+fmt.Sprintf("%#v", this.IngestionRate)+",\n")
	s = append(s, "NumSeries: "+fmt.Sprintf("%#v", this.NumSeries)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MetricsForLabelMatchersRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&client.MetricsForLabelMatchersRequest{")
	s = append(s, "StartTimestampMs: "+fmt.Sprintf("%#v", this.StartTimestampMs)+",\n")
	s = append(s, "EndTimestampMs: "+fmt.Sprintf("%#v", this.EndTimestampMs)+",\n")
	if this.MatchersSet != nil {
		s = append(s, "MatchersSet: "+fmt.Sprintf("%#v", this.MatchersSet)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MetricsForLabelMatchersResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&client.MetricsForLabelMatchersResponse{")
	if this.Metric != nil {
		s = append(s, "Metric: "+fmt.Sprintf("%#v", this.Metric)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TimeSeriesChunk) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&client.TimeSeriesChunk{")
	s = append(s, "FromIngesterId: "+fmt.Sprintf("%#v", this.FromIngesterId)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	if this.Labels != nil {
		vs := make([]*LabelPair, len(this.Labels))
		for i := range vs {
			vs[i] = &this.Labels[i]
		}
		s = append(s, "Labels: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	if this.Chunks != nil {
		vs := make([]*Chunk, len(this.Chunks))
		for i := range vs {
			vs[i] = &this.Chunks[i]
		}
		s = append(s, "Chunks: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Chunk) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&client.Chunk{")
	s = append(s, "StartTimestampMs: "+fmt.Sprintf("%#v", this.StartTimestampMs)+",\n")
	s = append(s, "EndTimestampMs: "+fmt.Sprintf("%#v", this.EndTimestampMs)+",\n")
	s = append(s, "Encoding: "+fmt.Sprintf("%#v", this.Encoding)+",\n")
	s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TransferChunksResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&client.TransferChunksResponse{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MessageTracker) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&client.MessageTracker{")
	s = append(s, "Labels: "+fmt.Sprintf("%#v", this.Labels)+",\n")
	s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LabelPair) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&client.LabelPair{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Sample) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&client.Sample{")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "TimestampMs: "+fmt.Sprintf("%#v", this.TimestampMs)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LabelMatchers) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&client.LabelMatchers{")
	if this.Matchers != nil {
		s = append(s, "Matchers: "+fmt.Sprintf("%#v", this.Matchers)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Metric) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&client.Metric{")
	if this.Labels != nil {
		vs := make([]*LabelPair, len(this.Labels))
		for i := range vs {
			vs[i] = &this.Labels[i]
		}
		s = append(s, "Labels: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LabelMatcher) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&client.LabelMatcher{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringAlertcortex(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for AlertIngester service

type AlertIngesterClient interface {
	Push(ctx context.Context, in *WriteRequest, opts ...grpc.CallOption) (*WriteResponse, error)
	Query(ctx context.Context, in *QueryRequest, opts ...grpc.CallOption) (*QueryResponse, error)
	LabelValues(ctx context.Context, in *LabelValuesRequest, opts ...grpc.CallOption) (*LabelValuesResponse, error)
	UserStats(ctx context.Context, in *UserStatsRequest, opts ...grpc.CallOption) (*UserStatsResponse, error)
	MetricsForLabelMatchers(ctx context.Context, in *MetricsForLabelMatchersRequest, opts ...grpc.CallOption) (*MetricsForLabelMatchersResponse, error)
	// TransferChunks allows leaving ingester (client) to stream chunks directly to joining ingesters (server).
	TransferChunks(ctx context.Context, opts ...grpc.CallOption) (AlertIngester_TransferChunksClient, error)
}

type alertIngesterClient struct {
	cc *grpc.ClientConn
}

func NewAlertIngesterClient(cc *grpc.ClientConn) AlertIngesterClient {
	return &alertIngesterClient{cc}
}

func (c *alertIngesterClient) Push(ctx context.Context, in *WriteRequest, opts ...grpc.CallOption) (*WriteResponse, error) {
	out := new(WriteResponse)
	err := grpc.Invoke(ctx, "/alertcortex.AlertIngester/Push", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertIngesterClient) Query(ctx context.Context, in *QueryRequest, opts ...grpc.CallOption) (*QueryResponse, error) {
	out := new(QueryResponse)
	err := grpc.Invoke(ctx, "/alertcortex.AlertIngester/Query", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertIngesterClient) LabelValues(ctx context.Context, in *LabelValuesRequest, opts ...grpc.CallOption) (*LabelValuesResponse, error) {
	out := new(LabelValuesResponse)
	err := grpc.Invoke(ctx, "/alertcortex.AlertIngester/LabelValues", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertIngesterClient) UserStats(ctx context.Context, in *UserStatsRequest, opts ...grpc.CallOption) (*UserStatsResponse, error) {
	out := new(UserStatsResponse)
	err := grpc.Invoke(ctx, "/alertcortex.AlertIngester/UserStats", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertIngesterClient) MetricsForLabelMatchers(ctx context.Context, in *MetricsForLabelMatchersRequest, opts ...grpc.CallOption) (*MetricsForLabelMatchersResponse, error) {
	out := new(MetricsForLabelMatchersResponse)
	err := grpc.Invoke(ctx, "/alertcortex.AlertIngester/MetricsForLabelMatchers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alertIngesterClient) TransferChunks(ctx context.Context, opts ...grpc.CallOption) (AlertIngester_TransferChunksClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_AlertIngester_serviceDesc.Streams[0], c.cc, "/alertcortex.AlertIngester/TransferChunks", opts...)
	if err != nil {
		return nil, err
	}
	x := &alertIngesterTransferChunksClient{stream}
	return x, nil
}

type AlertIngester_TransferChunksClient interface {
	Send(*TimeSeriesChunk) error
	CloseAndRecv() (*TransferChunksResponse, error)
	grpc.ClientStream
}

type alertIngesterTransferChunksClient struct {
	grpc.ClientStream
}

func (x *alertIngesterTransferChunksClient) Send(m *TimeSeriesChunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *alertIngesterTransferChunksClient) CloseAndRecv() (*TransferChunksResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(TransferChunksResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for AlertIngester service

type AlertIngesterServer interface {
	Push(context.Context, *WriteRequest) (*WriteResponse, error)
	Query(context.Context, *QueryRequest) (*QueryResponse, error)
	LabelValues(context.Context, *LabelValuesRequest) (*LabelValuesResponse, error)
	UserStats(context.Context, *UserStatsRequest) (*UserStatsResponse, error)
	MetricsForLabelMatchers(context.Context, *MetricsForLabelMatchersRequest) (*MetricsForLabelMatchersResponse, error)
	// TransferChunks allows leaving ingester (client) to stream chunks directly to joining ingesters (server).
	TransferChunks(AlertIngester_TransferChunksServer) error
}

func RegisterAlertIngesterServer(s *grpc.Server, srv AlertIngesterServer) {
	s.RegisterService(&_AlertIngester_serviceDesc, srv)
}

func _AlertIngester_Push_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertIngesterServer).Push(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alertcortex.AlertIngester/Push",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertIngesterServer).Push(ctx, req.(*WriteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertIngester_Query_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertIngesterServer).Query(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alertcortex.AlertIngester/Query",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertIngesterServer).Query(ctx, req.(*QueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertIngester_LabelValues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LabelValuesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertIngesterServer).LabelValues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alertcortex.AlertIngester/LabelValues",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertIngesterServer).LabelValues(ctx, req.(*LabelValuesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertIngester_UserStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertIngesterServer).UserStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alertcortex.AlertIngester/UserStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertIngesterServer).UserStats(ctx, req.(*UserStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertIngester_MetricsForLabelMatchers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MetricsForLabelMatchersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlertIngesterServer).MetricsForLabelMatchers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alertcortex.AlertIngester/MetricsForLabelMatchers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlertIngesterServer).MetricsForLabelMatchers(ctx, req.(*MetricsForLabelMatchersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlertIngester_TransferChunks_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AlertIngesterServer).TransferChunks(&alertIngesterTransferChunksServer{stream})
}

type AlertIngester_TransferChunksServer interface {
	SendAndClose(*TransferChunksResponse) error
	Recv() (*TimeSeriesChunk, error)
	grpc.ServerStream
}

type alertIngesterTransferChunksServer struct {
	grpc.ServerStream
}

func (x *alertIngesterTransferChunksServer) SendAndClose(m *TransferChunksResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *alertIngesterTransferChunksServer) Recv() (*TimeSeriesChunk, error) {
	m := new(TimeSeriesChunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _AlertIngester_serviceDesc = grpc.ServiceDesc{
	ServiceName: "alertcortex.AlertIngester",
	HandlerType: (*AlertIngesterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Push",
			Handler:    _AlertIngester_Push_Handler,
		},
		{
			MethodName: "Query",
			Handler:    _AlertIngester_Query_Handler,
		},
		{
			MethodName: "LabelValues",
			Handler:    _AlertIngester_LabelValues_Handler,
		},
		{
			MethodName: "UserStats",
			Handler:    _AlertIngester_UserStats_Handler,
		},
		{
			MethodName: "MetricsForLabelMatchers",
			Handler:    _AlertIngester_MetricsForLabelMatchers_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "TransferChunks",
			Handler:       _AlertIngester_TransferChunks_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "alertcortex.proto",
}

func (m *WriteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, msg := range m.Messages {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAlertcortex(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *WriteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ReadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Queries) > 0 {
		for _, msg := range m.Queries {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAlertcortex(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ReadResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Results) > 0 {
		for _, msg := range m.Results {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAlertcortex(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QueryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartTimestampMs != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAlertcortex(dAtA, i, uint64(m.StartTimestampMs))
	}
	if m.EndTimestampMs != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAlertcortex(dAtA, i, uint64(m.EndTimestampMs))
	}
	if len(m.Matchers) > 0 {
		for _, msg := range m.Matchers {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintAlertcortex(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QueryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, msg := range m.Messages {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAlertcortex(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *LabelValuesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabelValuesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.LabelName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlertcortex(dAtA, i, uint64(len(m.LabelName)))
		i += copy(dAtA[i:], m.LabelName)
	}
	return i, nil
}

func (m *LabelValuesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabelValuesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.LabelValues) > 0 {
		for _, s := range m.LabelValues {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *UserStatsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserStatsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *UserStatsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserStatsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IngestionRate != 0 {
		dAtA[i] = 0x9
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.IngestionRate))))
		i += 8
	}
	if m.NumSeries != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAlertcortex(dAtA, i, uint64(m.NumSeries))
	}
	return i, nil
}

func (m *MetricsForLabelMatchersRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricsForLabelMatchersRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartTimestampMs != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAlertcortex(dAtA, i, uint64(m.StartTimestampMs))
	}
	if m.EndTimestampMs != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAlertcortex(dAtA, i, uint64(m.EndTimestampMs))
	}
	if len(m.MatchersSet) > 0 {
		for _, msg := range m.MatchersSet {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintAlertcortex(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MetricsForLabelMatchersResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricsForLabelMatchersResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Metric) > 0 {
		for _, msg := range m.Metric {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAlertcortex(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TimeSeriesChunk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimeSeriesChunk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FromIngesterId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlertcortex(dAtA, i, uint64(len(m.FromIngesterId)))
		i += copy(dAtA[i:], m.FromIngesterId)
	}
	if len(m.UserId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlertcortex(dAtA, i, uint64(len(m.UserId)))
		i += copy(dAtA[i:], m.UserId)
	}
	if len(m.Labels) > 0 {
		for _, msg := range m.Labels {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintAlertcortex(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Chunks) > 0 {
		for _, msg := range m.Chunks {
			dAtA[i] = 0x22
			i++
			i = encodeVarintAlertcortex(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Chunk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Chunk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartTimestampMs != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAlertcortex(dAtA, i, uint64(m.StartTimestampMs))
	}
	if m.EndTimestampMs != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAlertcortex(dAtA, i, uint64(m.EndTimestampMs))
	}
	if m.Encoding != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAlertcortex(dAtA, i, uint64(m.Encoding))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAlertcortex(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *TransferChunksResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferChunksResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *MessageTracker) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageTracker) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Labels) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlertcortex(dAtA, i, uint64(len(m.Labels)))
		i += copy(dAtA[i:], m.Labels)
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAlertcortex(dAtA, i, uint64(m.Timestamp))
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAlertcortex(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *LabelPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabelPair) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAlertcortex(dAtA, i, uint64(m.Name.Size()))
	n1, err := m.Name.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintAlertcortex(dAtA, i, uint64(m.Value.Size()))
	n2, err := m.Value.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	return i, nil
}

func (m *Sample) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sample) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		dAtA[i] = 0x9
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Value))))
		i += 8
	}
	if m.TimestampMs != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAlertcortex(dAtA, i, uint64(m.TimestampMs))
	}
	return i, nil
}

func (m *LabelMatchers) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabelMatchers) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Matchers) > 0 {
		for _, msg := range m.Matchers {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAlertcortex(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Metric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metric) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for _, msg := range m.Labels {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAlertcortex(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *LabelMatcher) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabelMatcher) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAlertcortex(dAtA, i, uint64(m.Type))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlertcortex(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAlertcortex(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func encodeVarintAlertcortex(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *WriteRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovAlertcortex(uint64(l))
		}
	}
	return n
}

func (m *WriteResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ReadRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Queries) > 0 {
		for _, e := range m.Queries {
			l = e.Size()
			n += 1 + l + sovAlertcortex(uint64(l))
		}
	}
	return n
}

func (m *ReadResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.Size()
			n += 1 + l + sovAlertcortex(uint64(l))
		}
	}
	return n
}

func (m *QueryRequest) Size() (n int) {
	var l int
	_ = l
	if m.StartTimestampMs != 0 {
		n += 1 + sovAlertcortex(uint64(m.StartTimestampMs))
	}
	if m.EndTimestampMs != 0 {
		n += 1 + sovAlertcortex(uint64(m.EndTimestampMs))
	}
	if len(m.Matchers) > 0 {
		for _, e := range m.Matchers {
			l = e.Size()
			n += 1 + l + sovAlertcortex(uint64(l))
		}
	}
	return n
}

func (m *QueryResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovAlertcortex(uint64(l))
		}
	}
	return n
}

func (m *LabelValuesRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.LabelName)
	if l > 0 {
		n += 1 + l + sovAlertcortex(uint64(l))
	}
	return n
}

func (m *LabelValuesResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.LabelValues) > 0 {
		for _, s := range m.LabelValues {
			l = len(s)
			n += 1 + l + sovAlertcortex(uint64(l))
		}
	}
	return n
}

func (m *UserStatsRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *UserStatsResponse) Size() (n int) {
	var l int
	_ = l
	if m.IngestionRate != 0 {
		n += 9
	}
	if m.NumSeries != 0 {
		n += 1 + sovAlertcortex(uint64(m.NumSeries))
	}
	return n
}

func (m *MetricsForLabelMatchersRequest) Size() (n int) {
	var l int
	_ = l
	if m.StartTimestampMs != 0 {
		n += 1 + sovAlertcortex(uint64(m.StartTimestampMs))
	}
	if m.EndTimestampMs != 0 {
		n += 1 + sovAlertcortex(uint64(m.EndTimestampMs))
	}
	if len(m.MatchersSet) > 0 {
		for _, e := range m.MatchersSet {
			l = e.Size()
			n += 1 + l + sovAlertcortex(uint64(l))
		}
	}
	return n
}

func (m *MetricsForLabelMatchersResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Metric) > 0 {
		for _, e := range m.Metric {
			l = e.Size()
			n += 1 + l + sovAlertcortex(uint64(l))
		}
	}
	return n
}

func (m *TimeSeriesChunk) Size() (n int) {
	var l int
	_ = l
	l = len(m.FromIngesterId)
	if l > 0 {
		n += 1 + l + sovAlertcortex(uint64(l))
	}
	l = len(m.UserId)
	if l > 0 {
		n += 1 + l + sovAlertcortex(uint64(l))
	}
	if len(m.Labels) > 0 {
		for _, e := range m.Labels {
			l = e.Size()
			n += 1 + l + sovAlertcortex(uint64(l))
		}
	}
	if len(m.Chunks) > 0 {
		for _, e := range m.Chunks {
			l = e.Size()
			n += 1 + l + sovAlertcortex(uint64(l))
		}
	}
	return n
}

func (m *Chunk) Size() (n int) {
	var l int
	_ = l
	if m.StartTimestampMs != 0 {
		n += 1 + sovAlertcortex(uint64(m.StartTimestampMs))
	}
	if m.EndTimestampMs != 0 {
		n += 1 + sovAlertcortex(uint64(m.EndTimestampMs))
	}
	if m.Encoding != 0 {
		n += 1 + sovAlertcortex(uint64(m.Encoding))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovAlertcortex(uint64(l))
	}
	return n
}

func (m *TransferChunksResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *MessageTracker) Size() (n int) {
	var l int
	_ = l
	l = len(m.Labels)
	if l > 0 {
		n += 1 + l + sovAlertcortex(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovAlertcortex(uint64(m.Timestamp))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovAlertcortex(uint64(l))
	}
	return n
}

func (m *LabelPair) Size() (n int) {
	var l int
	_ = l
	l = m.Name.Size()
	n += 1 + l + sovAlertcortex(uint64(l))
	l = m.Value.Size()
	n += 1 + l + sovAlertcortex(uint64(l))
	return n
}

func (m *Sample) Size() (n int) {
	var l int
	_ = l
	if m.Value != 0 {
		n += 9
	}
	if m.TimestampMs != 0 {
		n += 1 + sovAlertcortex(uint64(m.TimestampMs))
	}
	return n
}

func (m *LabelMatchers) Size() (n int) {
	var l int
	_ = l
	if len(m.Matchers) > 0 {
		for _, e := range m.Matchers {
			l = e.Size()
			n += 1 + l + sovAlertcortex(uint64(l))
		}
	}
	return n
}

func (m *Metric) Size() (n int) {
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for _, e := range m.Labels {
			l = e.Size()
			n += 1 + l + sovAlertcortex(uint64(l))
		}
	}
	return n
}

func (m *LabelMatcher) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovAlertcortex(uint64(m.Type))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAlertcortex(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovAlertcortex(uint64(l))
	}
	return n
}

func sovAlertcortex(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAlertcortex(x uint64) (n int) {
	return sovAlertcortex(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *WriteRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WriteRequest{`,
		`Messages:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Messages), "MessageTracker", "MessageTracker", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WriteResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WriteResponse{`,
		`}`,
	}, "")
	return s
}
func (this *ReadRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReadRequest{`,
		`Queries:` + strings.Replace(fmt.Sprintf("%v", this.Queries), "QueryRequest", "QueryRequest", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReadResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReadResponse{`,
		`Results:` + strings.Replace(fmt.Sprintf("%v", this.Results), "QueryResponse", "QueryResponse", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueryRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueryRequest{`,
		`StartTimestampMs:` + fmt.Sprintf("%v", this.StartTimestampMs) + `,`,
		`EndTimestampMs:` + fmt.Sprintf("%v", this.EndTimestampMs) + `,`,
		`Matchers:` + strings.Replace(fmt.Sprintf("%v", this.Matchers), "LabelMatcher", "LabelMatcher", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueryResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueryResponse{`,
		`Messages:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Messages), "MessageTracker", "MessageTracker", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LabelValuesRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LabelValuesRequest{`,
		`LabelName:` + fmt.Sprintf("%v", this.LabelName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LabelValuesResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LabelValuesResponse{`,
		`LabelValues:` + fmt.Sprintf("%v", this.LabelValues) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UserStatsRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UserStatsRequest{`,
		`}`,
	}, "")
	return s
}
func (this *UserStatsResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UserStatsResponse{`,
		`IngestionRate:` + fmt.Sprintf("%v", this.IngestionRate) + `,`,
		`NumSeries:` + fmt.Sprintf("%v", this.NumSeries) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MetricsForLabelMatchersRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MetricsForLabelMatchersRequest{`,
		`StartTimestampMs:` + fmt.Sprintf("%v", this.StartTimestampMs) + `,`,
		`EndTimestampMs:` + fmt.Sprintf("%v", this.EndTimestampMs) + `,`,
		`MatchersSet:` + strings.Replace(fmt.Sprintf("%v", this.MatchersSet), "LabelMatchers", "LabelMatchers", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MetricsForLabelMatchersResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MetricsForLabelMatchersResponse{`,
		`Metric:` + strings.Replace(fmt.Sprintf("%v", this.Metric), "Metric", "Metric", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TimeSeriesChunk) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TimeSeriesChunk{`,
		`FromIngesterId:` + fmt.Sprintf("%v", this.FromIngesterId) + `,`,
		`UserId:` + fmt.Sprintf("%v", this.UserId) + `,`,
		`Labels:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Labels), "LabelPair", "LabelPair", 1), `&`, ``, 1) + `,`,
		`Chunks:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Chunks), "Chunk", "Chunk", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Chunk) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Chunk{`,
		`StartTimestampMs:` + fmt.Sprintf("%v", this.StartTimestampMs) + `,`,
		`EndTimestampMs:` + fmt.Sprintf("%v", this.EndTimestampMs) + `,`,
		`Encoding:` + fmt.Sprintf("%v", this.Encoding) + `,`,
		`Data:` + fmt.Sprintf("%v", this.Data) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TransferChunksResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TransferChunksResponse{`,
		`}`,
	}, "")
	return s
}
func (this *MessageTracker) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MessageTracker{`,
		`Labels:` + fmt.Sprintf("%v", this.Labels) + `,`,
		`Timestamp:` + fmt.Sprintf("%v", this.Timestamp) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LabelPair) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LabelPair{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Sample) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Sample{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`TimestampMs:` + fmt.Sprintf("%v", this.TimestampMs) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LabelMatchers) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LabelMatchers{`,
		`Matchers:` + strings.Replace(fmt.Sprintf("%v", this.Matchers), "LabelMatcher", "LabelMatcher", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Metric) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Metric{`,
		`Labels:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Labels), "LabelPair", "LabelPair", 1), `&`, ``, 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LabelMatcher) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LabelMatcher{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringAlertcortex(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *WriteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlertcortex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertcortex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlertcortex
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, MessageTracker{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlertcortex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlertcortex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlertcortex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAlertcortex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlertcortex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlertcortex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertcortex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlertcortex
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queries = append(m.Queries, &QueryRequest{})
			if err := m.Queries[len(m.Queries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlertcortex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlertcortex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlertcortex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertcortex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlertcortex
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, &QueryResponse{})
			if err := m.Results[len(m.Results)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlertcortex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlertcortex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlertcortex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimestampMs", wireType)
			}
			m.StartTimestampMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertcortex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTimestampMs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTimestampMs", wireType)
			}
			m.EndTimestampMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertcortex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTimestampMs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Matchers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertcortex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlertcortex
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Matchers = append(m.Matchers, &LabelMatcher{})
			if err := m.Matchers[len(m.Matchers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlertcortex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlertcortex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlertcortex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertcortex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlertcortex
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, MessageTracker{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlertcortex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlertcortex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabelValuesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlertcortex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabelValuesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabelValuesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertcortex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlertcortex
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LabelName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlertcortex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlertcortex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabelValuesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlertcortex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabelValuesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabelValuesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertcortex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlertcortex
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LabelValues = append(m.LabelValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlertcortex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlertcortex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserStatsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlertcortex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserStatsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserStatsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAlertcortex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlertcortex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserStatsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlertcortex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserStatsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserStatsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngestionRate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.IngestionRate = float64(math.Float64frombits(v))
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumSeries", wireType)
			}
			m.NumSeries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertcortex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumSeries |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAlertcortex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlertcortex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricsForLabelMatchersRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlertcortex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricsForLabelMatchersRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricsForLabelMatchersRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimestampMs", wireType)
			}
			m.StartTimestampMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertcortex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTimestampMs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTimestampMs", wireType)
			}
			m.EndTimestampMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertcortex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTimestampMs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchersSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertcortex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlertcortex
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchersSet = append(m.MatchersSet, &LabelMatchers{})
			if err := m.MatchersSet[len(m.MatchersSet)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlertcortex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlertcortex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricsForLabelMatchersResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlertcortex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricsForLabelMatchersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricsForLabelMatchersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertcortex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlertcortex
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metric = append(m.Metric, &Metric{})
			if err := m.Metric[len(m.Metric)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlertcortex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlertcortex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimeSeriesChunk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlertcortex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimeSeriesChunk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimeSeriesChunk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromIngesterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertcortex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlertcortex
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromIngesterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertcortex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlertcortex
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertcortex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlertcortex
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, LabelPair{})
			if err := m.Labels[len(m.Labels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertcortex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlertcortex
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chunks = append(m.Chunks, Chunk{})
			if err := m.Chunks[len(m.Chunks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlertcortex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlertcortex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Chunk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlertcortex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Chunk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Chunk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimestampMs", wireType)
			}
			m.StartTimestampMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertcortex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTimestampMs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTimestampMs", wireType)
			}
			m.EndTimestampMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertcortex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTimestampMs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			m.Encoding = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertcortex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Encoding |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertcortex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAlertcortex
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlertcortex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlertcortex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferChunksResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlertcortex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferChunksResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferChunksResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAlertcortex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlertcortex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageTracker) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlertcortex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: messageTracker: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: messageTracker: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertcortex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlertcortex
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertcortex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertcortex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlertcortex
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlertcortex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlertcortex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabelPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlertcortex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabelPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabelPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertcortex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAlertcortex
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Name.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertcortex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAlertcortex
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlertcortex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlertcortex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sample) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlertcortex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sample: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sample: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = float64(math.Float64frombits(v))
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampMs", wireType)
			}
			m.TimestampMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertcortex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimestampMs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAlertcortex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlertcortex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabelMatchers) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlertcortex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabelMatchers: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabelMatchers: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Matchers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertcortex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlertcortex
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Matchers = append(m.Matchers, &LabelMatcher{})
			if err := m.Matchers[len(m.Matchers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlertcortex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlertcortex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Metric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlertcortex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertcortex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlertcortex
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, LabelPair{})
			if err := m.Labels[len(m.Labels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlertcortex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlertcortex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabelMatcher) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlertcortex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabelMatcher: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabelMatcher: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertcortex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (MatchType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertcortex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlertcortex
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlertcortex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlertcortex
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlertcortex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlertcortex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAlertcortex(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAlertcortex
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAlertcortex
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAlertcortex
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAlertcortex
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAlertcortex
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAlertcortex(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAlertcortex = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAlertcortex   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("alertcortex.proto", fileDescriptorAlertcortex) }

var fileDescriptorAlertcortex = []byte{
	// 1024 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0x4f, 0x6f, 0x1b, 0x45,
	0x14, 0xf7, 0x24, 0x8e, 0x93, 0x7d, 0xfe, 0x93, 0x74, 0x8a, 0x52, 0xb3, 0xb4, 0x9b, 0xb0, 0x08,
	0xc9, 0x6a, 0x4b, 0x5c, 0x35, 0x41, 0xea, 0xa5, 0x40, 0x5c, 0x52, 0x08, 0x8a, 0xdd, 0x76, 0xe2,
	0x52, 0x40, 0x48, 0xab, 0x89, 0x3d, 0x71, 0x56, 0xf1, 0xee, 0xba, 0x33, 0xb3, 0x09, 0xb9, 0x71,
	0xe1, 0x0c, 0x5f, 0x80, 0x3b, 0x7c, 0x02, 0x2e, 0x7c, 0x80, 0x1e, 0x7b, 0x44, 0x1c, 0x2a, 0x62,
	0x2e, 0x1c, 0xfb, 0x11, 0xd0, 0xce, 0xec, 0x6e, 0x76, 0x53, 0xbb, 0x8a, 0x54, 0xf5, 0xb6, 0xf3,
	0xe6, 0xf7, 0x7e, 0xf3, 0x9b, 0xf7, 0xde, 0xbc, 0xb7, 0x70, 0x89, 0x0e, 0x19, 0x97, 0xbd, 0x80,
	0x4b, 0xf6, 0xc3, 0xda, 0x88, 0x07, 0x32, 0xc0, 0xe5, 0x8c, 0xc9, 0xfc, 0x68, 0xe0, 0xca, 0x83,
	0x70, 0x6f, 0xad, 0x17, 0x78, 0xcd, 0x41, 0x30, 0x08, 0x9a, 0x0a, 0xb3, 0x17, 0xee, 0xab, 0x95,
	0x5a, 0xa8, 0x2f, 0xed, 0x6b, 0xb7, 0xa1, 0xf2, 0x84, 0xbb, 0x92, 0x11, 0xf6, 0x34, 0x64, 0x42,
	0xe2, 0xbb, 0xb0, 0xe0, 0x31, 0x21, 0xe8, 0x80, 0x89, 0x3a, 0x5a, 0x9d, 0x6d, 0x94, 0x6f, 0xbf,
	0xb7, 0x96, 0x3d, 0x31, 0xde, 0xec, 0x72, 0xda, 0x3b, 0x64, 0xbc, 0x55, 0x7c, 0xf6, 0x62, 0xa5,
	0x40, 0x52, 0x17, 0x7b, 0x11, 0xaa, 0x31, 0x9d, 0x18, 0x05, 0xbe, 0x60, 0x76, 0x0b, 0xca, 0x84,
	0xd1, 0x7e, 0x42, 0xbf, 0x0e, 0xf3, 0x4f, 0x43, 0xc6, 0xdd, 0x94, 0xfd, 0xdd, 0x1c, 0xfb, 0xa3,
	0x90, 0xf1, 0x93, 0x18, 0x4b, 0x12, 0xa4, 0xfd, 0x39, 0x54, 0x34, 0x87, 0xe6, 0xc4, 0x1b, 0x30,
	0xcf, 0x99, 0x08, 0x87, 0x32, 0x21, 0x31, 0x27, 0x91, 0x68, 0x30, 0x49, 0xa0, 0xf6, 0xaf, 0x08,
	0x2a, 0x59, 0x7e, 0x7c, 0x13, 0xb0, 0x90, 0x94, 0x4b, 0x47, 0xba, 0x1e, 0x13, 0x92, 0x7a, 0x23,
	0xc7, 0x8b, 0x18, 0x51, 0x63, 0x96, 0x2c, 0xa9, 0x9d, 0x6e, 0xb2, 0xd1, 0x16, 0xb8, 0x01, 0x4b,
	0xcc, 0xef, 0xe7, 0xb1, 0x33, 0x0a, 0x5b, 0x63, 0x7e, 0x3f, 0x8b, 0xfc, 0x18, 0x16, 0x3c, 0x2a,
	0x7b, 0x07, 0x8c, 0x8b, 0xfa, 0xec, 0x84, 0x4b, 0xee, 0xd0, 0x3d, 0x36, 0x6c, 0x6b, 0x04, 0x49,
	0xa1, 0x76, 0x07, 0xaa, 0x39, 0xe5, 0x6f, 0x9a, 0x8a, 0x75, 0xc0, 0xea, 0xa4, 0xaf, 0xe9, 0x30,
	0x64, 0x22, 0xb9, 0xf4, 0x35, 0x80, 0x61, 0x64, 0x75, 0x7c, 0xea, 0x31, 0x75, 0x59, 0x83, 0x18,
	0xca, 0xd2, 0xa1, 0x1e, 0xb3, 0xef, 0xc0, 0xe5, 0x9c, 0x53, 0x2c, 0xe5, 0x7d, 0xa8, 0x68, 0xaf,
	0x23, 0x65, 0x57, 0x72, 0x0c, 0x52, 0x1e, 0x9e, 0x41, 0x6d, 0x0c, 0x4b, 0x8f, 0x05, 0xe3, 0xbb,
	0x92, 0xca, 0xe4, 0x30, 0xfb, 0x5b, 0xb8, 0x94, 0xb1, 0xc5, 0x5c, 0x1f, 0x42, 0xcd, 0xf5, 0x07,
	0x4c, 0x48, 0x37, 0xf0, 0x1d, 0x4e, 0xa5, 0x56, 0x81, 0x48, 0x35, 0xb5, 0x12, 0x2a, 0x59, 0x24,
	0xd4, 0x0f, 0x3d, 0x47, 0xe8, 0x62, 0x89, 0x22, 0x5d, 0x24, 0x86, 0x1f, 0x7a, 0xbb, 0xba, 0x26,
	0xfe, 0x40, 0x60, 0xb5, 0x99, 0xe4, 0x6e, 0x4f, 0xdc, 0x0f, 0x78, 0x36, 0xa4, 0xe2, 0x6d, 0xe7,
	0xf7, 0x2e, 0x54, 0x92, 0xa4, 0x39, 0x82, 0xc9, 0x38, 0xc7, 0xe6, 0xd4, 0x1c, 0x0b, 0x52, 0x4e,
	0xf0, 0xbb, 0x4c, 0xda, 0x1d, 0x58, 0x99, 0x2a, 0x3c, 0x0e, 0xd1, 0x0d, 0x28, 0x79, 0x0a, 0x12,
	0xe7, 0xfd, 0x72, 0x8e, 0x5b, 0x7b, 0x93, 0x18, 0x62, 0xff, 0x89, 0x60, 0x31, 0x92, 0xa7, 0x03,
	0x73, 0xef, 0x20, 0xf4, 0x0f, 0xa3, 0xcb, 0xec, 0xf3, 0xc0, 0x73, 0x74, 0x48, 0x19, 0x77, 0xdc,
	0x7e, 0x9c, 0xeb, 0x5a, 0x64, 0xdf, 0x8e, 0xcd, 0xdb, 0x7d, 0x7c, 0x05, 0xe6, 0x43, 0xa1, 0x01,
	0x33, 0x0a, 0x50, 0x8a, 0x96, 0xdb, 0x7d, 0xbc, 0x01, 0x25, 0x95, 0xde, 0xa4, 0x86, 0x97, 0x5f,
	0xbd, 0xdf, 0x43, 0xea, 0x26, 0x65, 0x17, 0x63, 0xf1, 0x2d, 0x28, 0xf5, 0x22, 0x05, 0xa2, 0x5e,
	0x54, 0x5e, 0x38, 0xe7, 0xa5, 0xc4, 0x25, 0x1e, 0x1a, 0x67, 0xff, 0x8c, 0x60, 0x4e, 0x8b, 0x7e,
	0x5b, 0xf9, 0x32, 0x61, 0x81, 0xf9, 0xbd, 0xa0, 0xef, 0xfa, 0x83, 0xfa, 0xec, 0x2a, 0x6a, 0xcc,
	0x91, 0x74, 0x8d, 0x31, 0x14, 0xfb, 0x54, 0xd2, 0x7a, 0x71, 0x15, 0x35, 0x2a, 0x44, 0x7d, 0xdb,
	0x75, 0x58, 0xee, 0x72, 0xea, 0x8b, 0x7d, 0xc6, 0x95, 0xb0, 0x34, 0x2f, 0xf6, 0xf7, 0x50, 0xcb,
	0x3f, 0x3a, 0xbc, 0x9c, 0x46, 0x49, 0x87, 0x37, 0x89, 0xc3, 0x55, 0x30, 0x52, 0x65, 0xb1, 0xac,
	0x33, 0x03, 0x7e, 0x07, 0xe6, 0xd4, 0x43, 0x52, 0x72, 0x0c, 0xa2, 0x17, 0xf6, 0xef, 0x08, 0x8c,
	0x34, 0xae, 0x78, 0x07, 0x8a, 0xe9, 0x13, 0xad, 0xb4, 0xee, 0x44, 0x31, 0xfb, 0xfb, 0xc5, 0xca,
	0xad, 0x4c, 0x77, 0x3f, 0x66, 0xf4, 0x88, 0x1d, 0x07, 0xfc, 0x50, 0x34, 0x75, 0x7c, 0x9b, 0xa3,
	0xc3, 0x41, 0x33, 0x94, 0xee, 0xb0, 0x79, 0xec, 0x72, 0xb6, 0xd6, 0x3a, 0x91, 0x4c, 0x10, 0xc5,
	0x82, 0x3b, 0xc9, 0x89, 0x33, 0x6f, 0x48, 0x17, 0x6b, 0xdd, 0x84, 0xd2, 0x2e, 0xf5, 0x46, 0x43,
	0x76, 0x76, 0x17, 0xfd, 0x8a, 0xf5, 0x22, 0x6a, 0x18, 0x13, 0x32, 0x53, 0x96, 0x67, 0x69, 0xb1,
	0xef, 0x43, 0x35, 0x57, 0xfd, 0xb9, 0xbe, 0x89, 0x2e, 0xde, 0x37, 0x3f, 0x81, 0x92, 0x7e, 0x11,
	0x99, 0x92, 0x45, 0x17, 0x2f, 0x59, 0xbb, 0x0f, 0x95, 0x2c, 0x33, 0xbe, 0x0e, 0x45, 0x79, 0x32,
	0xd2, 0xf7, 0xa9, 0x9d, 0xe3, 0x50, 0x98, 0xee, 0xc9, 0x88, 0x11, 0x85, 0x89, 0xca, 0x47, 0x25,
	0x49, 0x3f, 0x1d, 0x1d, 0xea, 0x89, 0xc9, 0xbd, 0xfe, 0x15, 0x18, 0xa9, 0x33, 0x36, 0x60, 0x6e,
	0xeb, 0xd1, 0xe3, 0xcd, 0x9d, 0xa5, 0x02, 0xae, 0x82, 0xd1, 0x79, 0xd0, 0x75, 0xf4, 0x12, 0xe1,
	0x45, 0x28, 0x93, 0xad, 0x2f, 0xb6, 0xbe, 0x71, 0xda, 0x9b, 0xdd, 0x7b, 0x5f, 0x2e, 0xcd, 0x60,
	0x0c, 0x35, 0x6d, 0xe8, 0x3c, 0x88, 0x6d, 0xb3, 0xb7, 0x7f, 0x2a, 0x42, 0x75, 0x33, 0x52, 0x95,
	0xbc, 0x63, 0xfc, 0x29, 0x14, 0x1f, 0x86, 0xe2, 0x00, 0xe7, 0x03, 0x96, 0x1d, 0xec, 0xa6, 0x39,
	0x69, 0x2b, 0xae, 0xeb, 0x02, 0xfe, 0x0c, 0xe6, 0xd4, 0xf0, 0xc1, 0xd3, 0xe7, 0xb1, 0xf9, 0x9a,
	0x29, 0x6b, 0x17, 0x30, 0x81, 0x72, 0x66, 0x72, 0xe0, 0x95, 0x57, 0x63, 0x9f, 0x1b, 0x44, 0xe6,
	0xea, 0x74, 0x40, 0xca, 0xb9, 0x03, 0x46, 0x3a, 0x3f, 0xf0, 0xb5, 0x9c, 0xc3, 0xf9, 0x59, 0x63,
	0x5a, 0xd3, 0xb6, 0x53, 0xb6, 0x23, 0xb8, 0x32, 0xa5, 0xf1, 0xe2, 0x1b, 0x13, 0x1a, 0xec, 0xb4,
	0xb9, 0x62, 0xde, 0xbc, 0x18, 0x38, 0x3d, 0xf7, 0x09, 0xd4, 0xf2, 0xfd, 0x04, 0x5f, 0xcd, 0x31,
	0x9c, 0x6b, 0xde, 0xe6, 0x07, 0xf9, 0xdd, 0xc9, 0xad, 0xa8, 0xd0, 0x40, 0xad, 0x8d, 0xe7, 0xa7,
	0x56, 0xe1, 0xaf, 0x53, 0xab, 0xf0, 0xf2, 0xd4, 0x42, 0x3f, 0x8e, 0x2d, 0xf4, 0xdb, 0xd8, 0x42,
	0xcf, 0xc6, 0x16, 0x7a, 0x3e, 0xb6, 0xd0, 0x3f, 0x63, 0x0b, 0xfd, 0x37, 0xb6, 0x0a, 0x2f, 0xc7,
	0x16, 0xfa, 0xe5, 0x5f, 0xab, 0xf0, 0x5d, 0xa9, 0x37, 0x74, 0x99, 0x2f, 0xf7, 0x4a, 0xea, 0xc7,
	0x6f, 0xfd, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xe9, 0x9d, 0x1e, 0x80, 0x49, 0x0a, 0x00, 0x00,
}
